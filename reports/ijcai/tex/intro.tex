\section{Introduction}\label{sec:intro}
Path planning for a single agent is considered a solved problem 
\cite{sharon2013}. When multiple agents have to find their way through a shared 
space then the problem becomes more complicated. The agents have to find paths 
around obstacles while they also need to ensure that they do not collide with 
each other. Even when agents can prevent collisions then it is still possible 
that congestions or even deadlocks may occur. To avoid these undesirable 
situations there is a need for coordination between the agents. This problem is 
addresd in the studo of what is called cooperative pathfinding. It finds its 
application in robotics, aviation, road traffic management, crowd simulations, 
and video games \cite{standley2011}.

%Discuss cooperative pathfinding and abstract solutions.
The most straightforward approach to the cooperative pathfinding problem
is to search the Cartesian product of the state spaces of all agents. This
approach is computationally inefficient \cite{sharon2013,hopcroft1984} as the 
time to find a solution is exponential in the number of agents. Another common 
approach is to impose a hierarchy on the agents by assigning them a unique 
priority. Agents plan a path to their destination in descending order of 
priority. When it is an agent's turn to plan their path they consider agents 
with a higher priority as moving obstacles \cite{bennewitz2002}.

These two common approaches to solving the cooperative pathfinding problem both
rely on a central processor for part of the process \cite{standley2010}. The 
first approach is a category of centralized methods that use a central 
processor to create a plan for all the agents. The other category requires that 
a central processor determines a priority ordering that the agents have to 
adhere to. After this has been done then the calculation of the plans for the 
agents can be decoupled, the agents create their plan on their own processor. 
There is also a third category of fully decentralized approaches. These do not 
use a central processor that can be a single point of failure. As a trade-off 
these methods usually have no global view of the problem. This means that 
agents can make decisions that will lead to congestions or deadlocks in the 
future without any agent noticing at the time that the decision was made.

% Argumentation
Methods of decentralised coordination have been developed by the field of
computational argumentation. Formal models of argumentation have been used in 
Artificial Intelligence in expert systems, multi-agent systems and law
\cite{vaneemeren2014}. Commonly argumentation in a multi-agent systems is 
modelled as a dialogue game. In such a dialogue game the agents represent the 
players and the game rules prescribes how the dialogue should occur 
\cite{walton1995}. There are rules about which arguments agent can put forward 
when they are allowed to do so. Most forms of dialogue games also have rules 
about when the dialogue is finished and which agent(s) have won if applicable.

% PGP
Without a central processor it is hard to create a plan that is globally well
coordinated. Partial global planning has been used in distributed sensor 
networks to distribute and coordinate tasks among the nodes that make up the 
network \cite{durfee1991}. The nodes create their individual plans without 
regard for each other. They will then exchange information on their plans and 
adapt them to better coordinate their activities. Coordination is not rigid and 
nodes have some freedom in how they execute their plan if circumstances change 
without the need to re-coordinate with the other nodes. None of the involved 
nodes ever has a global view, but the end result is a plan that is globally 
coordinated with each node holding the part of the global plan that is relevant 
to it.

%This method of constructing a global plan from local views can also be applied
%to cooperative pathfinding. Agents only have to coordinate with those agents
%that they have a conflicting path with. The freedom in planning allows agents
%to find an alternative path without having to update all other agents. Other
%agents that have previously been coordinated with don't need to update their
%plan as a response. This is only necessary when new conflicts arise because of
%the alternative path. This allows for a truly decentralised approach where
%agents  only communicate with other agents when they have to. There is also no
%need to wait for a central processor to tell agents what to do. At the same
%time plans are well coordinated without lacking a global view like the
%decentralized cooperative pathfinding algorithms.

% describe how to combine these three views
Dialogues can be used in cooperative pathfinding by applying techniques from
partial global planning. When agents have a conflict then they need to
cooperate to resolve it. They can do so by starting a dialogue in which
they share and evaluate different hypothesis to solve the conflict. A
hypothesis consists of a priority ordering for the agents that are involved in
the conflict. The hypotheses offered will be discussed and evaluated in the
dialogue and the agents will select the most preferred proposal as the solution 
to the conflict. All agents involved in the dialogue adapt the priority 
ordering. Next they update their plan so that they adhere to the constraints 
set by the priority ordering. This means that there are many small local 
changes to an agent's position in the global hierarchy and therefore also in 
their plans. The end result is a global solution to the cooperative pathfinding 
problem without any agent having known it explicitly. There is also no single 
agent which has been vital to its calculation like in a centralized approach.

The rest of this article is structured as follows. First, a formal description
of the cooperative pathfinding problem is given in \autoref{sec:problem}.
Previous work in cooperative pathfinding, argumentation and partial global
planning is discussed in \autoref{sec:related}. A new method to find
conflict-free paths is proposed in \autoref{sec:method}. The method is
evaluated and compared to other algorithms in \autoref{sec:results}. Final
remarks on the proposed method and its implications are discussed in
\autoref{sec:discussion}.
